# **925. Long Pressed Name**

Got it! Let's break down **LeetCode 925: Long Pressed Name** step by step.

---

## **1Ô∏è‚É£ Problem Understanding**

**Problem Statement:**  
You are given two strings:

- `name`: The correct spelling of a person's name.
- `typed`: The string entered by a person who might have long-pressed some keys.

You need to determine if `typed` could have been generated by **long-pressing** some characters while typing `name`.

### **Example Scenarios**

#### ‚úÖ Valid Cases

```plaintext
Input: name = "alex", typed = "aaleex"
Output: true
```

Explanation: The letters `'a'` and `'e'` were long-pressed.

```plaintext
Input: name = "saeed", typed = "ssaaedd"
Output: false
```

Explanation: `'e'` must appear twice in sequence, but it's missing from `typed`.

### **Constraints & Edge Cases**

- `1 <= name.length, typed.length <= 1000`
- `name` and `typed` contain **only lowercase English letters**.
- `typed` **must** contain all characters from `name` in the correct order.
- `typed` **may** contain extra characters, but they must match a long-pressed character.

---

## **2Ô∏è‚É£ Pattern Identification**

This problem is best solved using the **Two Pointers** technique:

- One pointer (`i`) iterates over `name`.
- Another pointer (`j`) iterates over `typed`.
- We check if characters in `typed` match `name` while allowing long presses.

This **resembles** problems like:

- **Merge Two Sorted Lists**
- **Valid Subsequence**

---

## **3Ô∏è‚É£ Approach Discussion**

We will use **Two Pointers** (`i` for `name`, `j` for `typed`):

### **Step-by-Step Breakdown**

1. Initialize `i = 0` (for `name`) and `j = 0` (for `typed`).
2. Iterate over `typed` (`j < typed.length`):
   - If `typed[j]` matches `name[i]`: Move both pointers.
   - If `typed[j]` matches `typed[j-1]`: This is a long press ‚Üí Move only `j`.
   - Otherwise, return `False` (invalid character encountered).
3. Ensure that all characters in `name` were checked (`i == name.length`).
4. Return `True` if we successfully iterated over both strings.

---

## **4Ô∏è‚É£ Code Implementation (JavaScript)**

Here's the **JavaScript** implementation:

```javascript
var isLongPressedName = function (name, typed) {
  let i = 0,
    j = 0; // Two pointers

  while (j < typed.length) {
    if (i < name.length && name[i] === typed[j]) {
      // Match: Move both pointers
      i++;
      j++;
    } else if (j > 0 && typed[j] === typed[j - 1]) {
      // Long press detected: Move `j`
      j++;
    } else {
      // Mismatch: Invalid case
      return false;
    }
  }

  // Ensure `name` was fully traversed
  return i === name.length;
};
```

---

## **5Ô∏è‚É£ Complexity Analysis**

- **Time Complexity:** `O(n + m)` (Linear time)
  - Each pointer moves at most once through `name` and `typed`.
- **Space Complexity:** `O(1)`
  - Only two integer variables (`i` and `j`) are used.

---

## **6Ô∏è‚É£ Alternative Solutions**

### **Using String Grouping**

Instead of **two pointers**, we can:

1. **Group consecutive characters** in `name` and `typed`.
2. **Compare the grouped characters and their counts**.

While possible, this requires **extra space** and has the same time complexity.

---

## **7Ô∏è‚É£ Practice Recommendations**

To master the **Two Pointers** pattern, try:

1. **392. Is Subsequence** (Easy)
2. **844. Backspace String Compare** (Easy)
3. **11. Container With Most Water** (Medium)
4. **424. Longest Repeating Character Replacement** (Medium)

---

## **8Ô∏è‚É£ Flowchart Design**

Let's create a **flowchart** to visualize the algorithm. Stay tuned! üé®üìå

Here's the **flowchart** illustrating the key steps of our solution! üìù This visualization should help you better understand the logic flow of the **two-pointer** approach.

Would you like further clarifications on any part? üöÄ
